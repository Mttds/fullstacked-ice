# React contd

- functional programming in JavaScript (Map, Reduce, Higher-order functions)

```javascript
// Because the code generating the li tags is JavaScript,
// it must be wrapped in curly braces in a JSX template just like all other JavaScript code.
// The elements generated by the map method, must each have a unique key value: an attribute called key.
// React uses the key attributes of objects in an array to determine how
// to update the view generated by a component when the component is re-rendered
const App = (props) => {
  const { notes } = props;

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map((note) => (
          <li key={note.id}>{note.content}</li>
        ))}
      </ul>
    </div>
  );
};

// OR
// This is, however, not recommended and can create undesired problems even if it seems to be working just fine.
<ul>
  {notes.map((note, i) => (
    <li key={i}>{note.content}</li>
  ))}
</ul>;
```

- exporting components and using them

```javascript
// Note.jsx
const Note = ({ note }) => {
  return <li>{note.content}</li>;
};

export default Note;

// App.jsx
// Note that when importing our own components, their location must be given in relation to the importing file
// The filename extension .jsx can be omitted.
import Note from "./components/Note";
const App = ({ notes }) => {
  // ...
};
```

- forms

```javascript
const App = (props) => {
  const [notes, setNotes] = useState(props.notes);

  // The event parameter is the event that triggers the call to the event handler function:
  // The event handler immediately calls the event.preventDefault() method,
  // which prevents the default action of submitting a form.
  // The default action would, among other things, cause the page to reload.
  // The target of the event stored in event.target is logged to the console
  // The target in this case is the form that we have defined in our component
  const addNote = (event) => {
    event.preventDefault();
    console.log("button clicked", event.target);
  };

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map((note) => (
          <Note key={note.id} note={note} />
        ))}
      </ul>
      <form onSubmit={addNote}>
        <input />
        <button type="submit">save</button>
      </form>
    </div>
  );
};
```

- controlled component

```javascript
const App = (props) => {
  const [notes, setNotes] = useState(props.notes);

  // new piece of state called newNote for storing the user-submitted input
  // set it as the input element's value attribute
  // Since we assigned a piece of the App component's state as the value attribute of the input element,
  // the App component now controls the behavior of the input element.

  // To enable editing of the input element, we have to register
  // an event handler that synchronizes the changes made to the input with the component's state (handleNoteChange)
  const [newNote, setNewNote] = useState("a new note...");

  const addNote = (event) => {
    event.preventDefault();
    console.log("button clicked", event.target);
    const noteObject = {
      content: newNote,
      important: Math.random() < 0.5,
      id: notes.length + 1,
    };

    // The method does not mutate the original notes array
    // This is important since we must never mutate state directly in React!
    setNotes(notes.concat(noteObject));
    setNewNote("");
  };

  // Note that we did not need to call the event.preventDefault()
  // method like we did in the onSubmit event handler.
  // This is because no default action occurs on an input change, unlike a form submission.
  const handleNoteChange = (event) => {
    console.log(event.target.value);
    setNewNote(event.target.value);
  };

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map((note) => (
          <Note key={note.id} note={note} />
        ))}
      </ul>
      <form onSubmit={addNote}>
        <input value={newNote} onChange={handleNoteChange} />
        <button type="submit">save</button>
      </form>
    </div>
  );
};
```

- filtering displayed elements

```javascript
const App = (props) => {
  const [notes, setNotes] = useState(props.notes);
  const [newNote, setNewNote] = useState("a new note...");
  const [showAll, setShowAll] = useState(true);

  const notesToShow = showAll
    ? notes
    : notes.filter((note) => note.important /*=== true*/); //note.important is already a boolean

  const addNote = (event) => {
    event.preventDefault();
    console.log("button clicked", event.target);
    const noteObject = {
      content: newNote,
      important: Math.random() < 0.5,
      id: notes.length + 1,
    };

    setNotes(notes.concat(noteObject));
    setNewNote("");
  };

  const handleNoteChange = (event) => {
    console.log(event.target.value);
    setNewNote(event.target.value);
  };

  // The displayed notes (all versus important) are controlled with a button.
  // The event handler for the button is so simple that it has been defined directly in the attribute of the button element.
  // The event handler switches the value of showAll from true to false and vice versa (() => setShowAll(!showAll))
  // The text of the button depends on the value of the showAll state (showAll ? "important" : "all")
  return (
    <div>
      <h1>Notes</h1>
      <div>
        <button onClick={() => setShowAll(!showAll)}>
          show {showAll ? "important" : "all"}
        </button>
      </div>
      <ul>
        {notesToShow.map((note) => (
          <Note key={note.id} note={note} />
        ))}
      </ul>
      <form onSubmit={addNote}>
        <input value={newNote} onChange={handleNoteChange} />
        <button type="submit">save</button>
      </form>
    </div>
  );
};
```

- getting data from the server

To mock a backend server:

```
// db.json is a file containing JSON data
// from the root project folder (i.e. part2)
npm install json-server // --save-dev if only for dev dependency

// this is only needed if we want to run it globally (i.e. installed with -g)
//json-server --port 3001 --watch db.json

npx json-server --port 3001 --watch db.json
```

Legacy AJAX API (XHR) for server-browser communication (async).

```javascript
const xhttp = new XMLHttpRequest();

xhttp.onreadystatechange = function () {
  if (this.readyState == 4 && this.status == 200) {
    const data = JSON.parse(this.responseText);
    // handle the response that is saved in variable data
  }
};

xhttp.open("GET", "/data.json", true);
xhttp.send();
```

In today's browsers, it is possible to run parallelized code with the help of so-called web workers. The event loop of an individual browser window is, however, still only handled by a single thread.

We could use the promise-based function fetch (modern browser API) to pull the data from the server. Fetch is a great tool. It is standardized and supported by all modern browsers (excluding IE).
Another alternative is using a library like axios.

```
npm install axios
```

Added to package.json to be able to run `npm run server` to run our json backend server.

```
{
  // ...
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview",

    "server": "json-server -p3001 --watch db.json"
  },
}
```

- Promises (axios, fetch):

A promise is an object that represents an asynchronous operation. A promise can have three distinct states:

The promise is pending: It means that the final value (one of the following two) is not available yet.

The promise is fulfilled: It means that the operation has been completed and the final value is available, which generally is a successful operation. This state is sometimes also called resolved.

The promise is rejected: It means that an error prevented the final value from being determined, which generally represents a failed operation.

If, and when, we want to access the result of the operation represented by the promise, we must register an event handler to the promise. This is achieved using the method then:

```javascript
const promise = axios.get("http://localhost:3001/notes");

promise.then((response) => {
  console.log(response);
  console.log(response.data);
});
```

The response object contains all the essential data related to the response of an HTTP GET request, which would include the returned data, status code, and headers.

A more readable way to format chained method calls is to place each call on its own line.

```javascript
axios.get("http://localhost:3001/notes").then((response) => {
  const notes = response.data;
  console.log(notes);
});
```

The data returned by the server is plain text, basically just one long string. The axios library is still able to parse the data into a JavaScript array, since the server has specified that the data format is application/json; charset=utf-8.

- Effect Hooks

The Effect Hook lets you perform side effects on function components. Data fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects.

```javascript
import { useState, useEffect } from "react";
import axios from "axios";
import Note from "./components/Note";

const App = () => {
  const [notes, setNotes] = useState([]);
  const [newNote, setNewNote] = useState("");
  const [showAll, setShowAll] = useState(true);

  useEffect(() => {
    console.log("effect");
    axios.get("http://localhost:3001/notes").then((response) => {
      console.log("promise fulfilled");
      setNotes(response.data);
    });
  }, []);
  console.log("render", notes.length, "notes");

  // ...
};
```

First, the body of the function defining the component is executed and the component is rendered for the first time. At this point render 0 notes is printed, meaning data hasn't been fetched from the server yet.

Then the function definition passed to useEffect is executed immediately after rendering.

The execution of the function results in effect being printed to the console, and the command axios.get initiates the fetching of data from the server as well as registers the following function as an event handler for the operation.

```javascript
(response) => {
  console.log("promise fulfilled");
  setNotes(response.data);
};
```

When data arrives from the server, the JavaScript runtime calls the function registered as the event handler, which prints promise fulfilled to the console and stores the notes received from the server into the state using the function setNotes(response.data).

As always, a call to a state-updating function triggers the re-rendering of the component. As a result, render 3 notes is printed to the console, and the notes fetched from the server are rendered to the screen.

A useEffect hook can be also written as:

```javascript
const hook = () => {
  console.log("effect");
  axios.get("http://localhost:3001/notes").then((response) => {
    console.log("promise fulfilled");
    setNotes(response.data);
  });
};

useEffect(hook, []);
```

The second parameter of useEffect is used to specify how often the effect is run.

If the second parameter is an empty array [], then the effect is only run along with the first render of the component.

Another way to write it separating the promise and the event handler in separate variables instead of chaining the function calls.

```javascript
useEffect(() => {
  console.log("effect");

  const eventHandler = (response) => {
    console.log("promise fulfilled");
    setNotes(response.data);
  };

  const promise = axios.get("http://localhost:3001/notes");
  promise.then(eventHandler);
}, []);
```

- REST

In REST terminology, we refer to individual data objects, such as the notes in our application, as resources. Every resource has a unique address associated with it - its URL. According to a general convention used by json-server, we would be able to locate an individual note at the resource URL notes/3, where 3 is the id of the resource. The notes URL, on the other hand, would point to a resource collection containing all the notes.

Resources are fetched from the server with HTTP GET requests. For instance, an HTTP GET request to the URL notes/3 will return the note that has the id number 3. An HTTP GET request to the notes URL would return a list of all notes.

Creating a new resource for storing a note is done by making an HTTP POST request to the notes URL according to the REST convention that the json-server adheres to. The data for the new note resource is sent in the body of the request.

```javascript
// POST request to the server
addNote = (event) => {
  event.preventDefault();
  const noteObject = {
    content: newNote,
    important: Math.random() > 0.5,
  };

  axios.post("http://localhost:3001/notes", noteObject).then((response) => {
    setNotes(notes.concat(response.data));
    setNewNote("");
  });
};
```

Using put to change existing data.

```javascript
// { ...note } creates a new object with copies of all the properties from the note object.
// When we add properties inside the curly braces after the spread object, e.g.
// { ...note, important: true }, then the value of the important property of the new object will be true.
// In our example, the important property gets the negation of its previous value in the original object.
// This is done because we don't want to mutate state directly.
const toggleImportanceOf = (id) => {
  const url = `http://localhost:3001/notes/${id}`;
  const note = notes.find((n) => n.id === id);
  const changedNote = { ...note, important: !note.important };

  axios.put(url, changedNote).then((response) => {
    // reset the notes with the updated data returned from the server
    // for the changed note, otherwise reset existing data
    setNotes(notes.map((n) => (n.id !== id ? n : response.data)));
  });
};
```

- Extracting communication with the server in separate modules

It's good practice to put server comms in separate files in the src/services folder.

For example:

```javascript
// src/services/notes.js
import axios from "axios";
const baseUrl = "http://localhost:3001/notes";

const getAll = () => {
  const request = axios.get(baseUrl);
  return request.then((response) => response.data);
};

const create = (newObject) => {
  const request = axios.post(baseUrl, newObject);
  return request.then((response) => response.data);
};

const update = (id, newObject) => {
  const request = axios.put(`${baseUrl}/${id}`, newObject);
  return request.then((response) => response.data);
};

// export object with keys and values (functions)
// keys can also be defined with different names
// when keys and values are the same we can write also
// export default { getAll, create, update }
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#property_definitions
export default {
  getAll: getAll,
  create: create,
  update: update,
};
```

And then used in the React component:

```javascript
import noteService from "./services/notes";

const App = () => {
  // ...

  useEffect(() => {
    noteService.getAll().then((initialNotes) => {
      setNotes(initialNotes);
    });
  }, []);

  const toggleImportanceOf = (id) => {
    const note = notes.find((n) => n.id === id);
    const changedNote = { ...note, important: !note.important };

    noteService.update(id, changedNote).then((updatedNote) => {
      setNotes(notes.map((note) => (note.id !== id ? note : updatedNote)));
    });
  };

  const addNote = (event) => {
    event.preventDefault();
    const noteObject = {
      content: newNote,
      important: Math.random() > 0.5,
    };

    noteService.create(noteObject).then((addedNote) => {
      setNotes(notes.concat(addedNote));
      setNewNote("");
    });
  };

  // ...
};

export default App;
```

- Handling errors (promise rejected)

The rejection of a promise is handled by providing the then method with a second callback function, which is called in the situation where the promise is rejected.

The more common way of adding a handler for rejected promises is to use the catch method.

```javascript
axios
  .get("http://example.com/probably_will_fail")
  .then((response) => {
    console.log("success!");
  })
  .catch((error) => {
    console.log("fail");
  });
```

catch is put at the end of a promise chain.

```javascript
axios
  .put(`${baseUrl}/${id}`, newObject)
  .then((response) => response.data)
  .then((changedNote) => {
    // ...
  })
  .catch((error) => {
    console.log("fail");
  });
```

```javascript
const toggleImportanceOf = (id) => {
  const note = notes.find((n) => n.id === id);
  const changedNote = { ...note, important: !note.important };

  noteService
    .update(id, changedNote)
    .then((returnedNote) => {
      setNotes(notes.map((note) => (note.id !== id ? note : returnedNote)));
    })

    .catch((error) => {
      alert(`the note '${note.content}' was already deleted from server`);
      setNotes(notes.filter((n) => n.id !== id));
    });
};
```
